{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory Name",
			"defaultValue": "NESBITTestFactory-2003190950"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/CreateTermsSwappedBranches')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This is the Create Terms dataflow and include lookups to the TermTypeTable in the Taxonomy db.",
				"folder": {
					"name": "CreateTerms"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ThesaurusTerms",
								"type": "DatasetReference"
							},
							"name": "ThesaurusTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimID as integer,\n\t\tDimName as string,\n\t\tRootID as integer,\n\t\tDimPreferred as boolean,\n\t\tDimSourceID as integer,\n\t\tDimDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> ThesaurusTerms"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermID as integer,\n\t\tTermDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyTerms"
						},
						{
							"dataset": {
								"referenceName": "TermTypeSink",
								"type": "DatasetReference"
							},
							"name": "TermTypes",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TermTypes"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "TaxonomyTermsInsert",
							"script": "SelectForInsertion sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tmapColumn(\n\t\tDimID = TermTypeID,\n\t\tTermCode,\n\t\tTermName = DimName,\n\t\tDescription = DimDescription,\n\t\tPreferred = DimPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> TaxonomyTermsInsert"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "DeleteSink",
							"script": "SelectForDelete sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['DimID'],\n\tmapColumn(\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred = DimPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> DeleteSink"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "UpdateTerm",
							"script": "SelectForUpdate sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermID'],\n\tmapColumn(\n\t\tTermID,\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred = DimPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> UpdateTerm"
						}
					],
					"transformations": [
						{
							"name": "ConvertDimIDToTypeID",
							"script": "Filter1 derive(PossibleTypeID = toShort(DimID)) ~> ConvertDimIDToTypeID"
						},
						{
							"name": "LookupTypesWithDimID",
							"script": "ConvertDimIDToTypeID, TermTypes join(DimName == TypeName\n\t&& DimSourceID == SourceID\n\t&& PossibleTypeID == TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupTypesWithDimID"
						},
						{
							"name": "MergeJoin",
							"script": "SelectFromLookup, TaxonomyTerms join(DimID == TermDimID,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit1",
							"script": "Select1 split(isNull(DimID),\n\tnot(isNull(TermID)) && not(isNull(DimID)),\n\tdisjoint: true) ~> ConditionalSplit1@(Delete, Update, Insert)"
						},
						{
							"name": "SelectForDelete",
							"script": "ConditionsForDelete select(mapColumn(\n\t\tDimPreferred,\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tTermDescription,\n\t\tTermPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t))~> SelectForDelete"
						},
						{
							"name": "AddAvailableCol",
							"script": "ConditionalSplit1@Delete derive(Available = false()) ~> AddAvailableCol"
						},
						{
							"name": "ConditionsForDelete",
							"script": "AddAvailableCol alterRow(updateIf(isNull(DimID))) ~> ConditionsForDelete"
						},
						{
							"name": "ConvertNameAndDesc",
							"script": "ConditionalSplit1@Update derive(DimTypeName = left(DimName, 80),\n\t\tDimTypeDescription = left(DimDescription, 500)) ~> ConvertNameAndDesc"
						},
						{
							"name": "ConditionsForUpdate",
							"script": "ConvertNameAndDesc alterRow(updateIf(not(isNull(TermID))&&not(isNull(TermDimID)))) ~> ConditionsForUpdate"
						},
						{
							"name": "SelectForUpdate",
							"script": "ConditionsForUpdate select(mapColumn(\n\t\tDimPreferred,\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName = DimName,\n\t\tTermDescription = DimDescription,\n\t\tTermPreferred = DimPreferred,\n\t\tAvailable,\n\t\tTermTypeID = PossibleTypeID,\n\t\tTermID\n\t))~> SelectForUpdate"
						},
						{
							"name": "TermIdIsNull",
							"script": "ConditionalSplit1@Insert filter(isNull(TermID)) ~> TermIdIsNull"
						},
						{
							"name": "SetAvailable",
							"script": "TermIdIsNull derive(Available = true(),\n\t\tRootTypeID = toShort(RootID)) ~> SetAvailable"
						},
						{
							"name": "LookupTypeWithRootID",
							"script": "SetAvailable, TermTypes join(RootID == TermTypes@TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupTypeWithRootID"
						},
						{
							"name": "SelectFromLookup",
							"script": "LookupTypesWithDimID select(mapColumn(\n\t\tDimID,\n\t\tRootID,\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tDimSourceID,\n\t\tAvailable\n\t))~> SelectFromLookup"
						},
						{
							"name": "ConditionsForInsertion",
							"script": "LookupTypeWithRootID alterRow(insertIf(not(isNull(DimID)))) ~> ConditionsForInsertion"
						},
						{
							"name": "SelectForInsertion",
							"script": "ConditionsForInsertion select(mapColumn(\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tTermCode,\n\t\tAvailable = SetAvailable@Available,\n\t\tTermTypeID = PossibleTypeID\n\t))~> SelectForInsertion"
						},
						{
							"name": "Filter1",
							"script": "ThesaurusTerms filter(DimID == 11949) ~> Filter1"
						},
						{
							"name": "Select1",
							"script": "MergeJoin select(mapColumn(\n\t\tDimID,\n\t\tRootID,\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tDimSourceID,\n\t\tTermID,\n\t\tTermDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tTermDescription,\n\t\tTermPreferred,\n\t\tAvailable = TaxonomyTerms@Available,\n\t\tTermTypeID\n\t))~> Select1"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DeleteFromTableTesting')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This is the Create Terms dataflow and include lookups to the TermTypeTable in the Taxonomy db.",
				"folder": {
					"name": "CreateTerms"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ThesaurusTerms",
								"type": "DatasetReference"
							},
							"name": "ThesaurusTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimID as integer,\n\t\tDimName as string,\n\t\tRootID as integer,\n\t\tDimPreferred as boolean,\n\t\tDimSourceID as integer,\n\t\tDimDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> ThesaurusTerms"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermID as integer,\n\t\tTermDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyTerms"
						},
						{
							"dataset": {
								"referenceName": "TermType",
								"type": "DatasetReference"
							},
							"name": "TermTypes",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TermTypes"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"script": "SelectForInsertion sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['DimID'],\n\tmapColumn(\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred,\n\t\tDimID,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> sink1"
						}
					],
					"transformations": [
						{
							"name": "ConvertDimIDToTypeID",
							"script": "ThesaurusTerms derive(PossibleTypeID = toShort(DimID)) ~> ConvertDimIDToTypeID"
						},
						{
							"name": "LookupTypesWithDimID",
							"script": "ConvertDimIDToTypeID, TermTypes join(DimName == TypeName\n\t&& DimSourceID == SourceID\n\t&& PossibleTypeID == TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupTypesWithDimID"
						},
						{
							"name": "MergeJoin",
							"script": "Select1, TaxonomyTerms join(DimID == TermDimID,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit1",
							"script": "Filter1 split(isNull(DimID),\n\tdisjoint: false) ~> ConditionalSplit1@(Delete, Default)"
						},
						{
							"name": "Select1",
							"script": "LookupTypesWithDimID select(mapColumn(\n\t\tDimID,\n\t\tRootID,\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tDimSourceID\n\t))~> Select1"
						},
						{
							"name": "SelectForInsertion",
							"script": "DerivedColumn1 select(mapColumn(\n\t\tDimPreferred,\n\t\tTermDescription,\n\t\tTermName,\n\t\tTermCode,\n\t\tDimID = TermDimID,\n\t\tAvailable,\n\t\tTermTypeID,\n\t\tPreferred = TermPreferred\n\t))~> SelectForInsertion"
						},
						{
							"name": "AlterRow2",
							"script": "ConditionalSplit1@Delete alterRow(updateIf(TermID==286337)) ~> AlterRow2"
						},
						{
							"name": "Filter1",
							"script": "MergeJoin filter(TermID == 286337) ~> Filter1"
						},
						{
							"name": "DerivedColumn1",
							"script": "AlterRow2 derive(Available = false()) ~> DerivedColumn1"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/InsertToTableTesting')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This is the Create Terms dataflow and include lookups to the TermTypeTable in the Taxonomy db.",
				"folder": {
					"name": "CreateTerms"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ThesaurusTerms",
								"type": "DatasetReference"
							},
							"name": "ThesaurusTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimID as integer,\n\t\tDimName as string,\n\t\tRootID as integer,\n\t\tDimPreferred as boolean,\n\t\tDimSourceID as integer,\n\t\tDimDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> ThesaurusTerms"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermID as integer,\n\t\tTermDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyTerms"
						},
						{
							"dataset": {
								"referenceName": "TermType",
								"type": "DatasetReference"
							},
							"name": "TermTypes",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TermTypes"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "InsertSink",
							"script": "Select2 sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tmapColumn(\n\t\tDimID = TermTypeID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred = TermPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> InsertSink"
						}
					],
					"transformations": [
						{
							"name": "ConvertDimIDToTypeID",
							"script": "ThesaurusTerms derive(PossibleTypeID = toShort(DimID)) ~> ConvertDimIDToTypeID"
						},
						{
							"name": "LookupTypesWithDimID",
							"script": "ConvertDimIDToTypeID, TermTypes join(DimName == TypeName\n\t&& DimSourceID == SourceID\n\t&& PossibleTypeID == TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupTypesWithDimID"
						},
						{
							"name": "MergeJoin",
							"script": "Select1, TaxonomyTerms join(DimID == TermDimID,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "Select1",
							"script": "LookupTypesWithDimID select(mapColumn(\n\t\tDimID,\n\t\tRootID,\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tDimSourceID\n\t))~> Select1"
						},
						{
							"name": "InsertBranch",
							"script": "MergeJoin filter(isNull(TermID)) ~> InsertBranch"
						},
						{
							"name": "SetAvailable",
							"script": "InsertBranch derive(Available = true(),\n\t\tRootTypeID = toShort(RootID)) ~> SetAvailable"
						},
						{
							"name": "Lookup1",
							"script": "SetAvailable, TermTypes lookup(RootTypeID == TermTypes@TermTypeID,\n\tbroadcast: 'none')~> Lookup1"
						},
						{
							"name": "DerivedColumn1",
							"script": "Lookup1 derive(DimTypeName = left(DimName, 80),\n\t\tDimTypeDescription = left(DimDescription, 500)) ~> DerivedColumn1"
						},
						{
							"name": "AlterRow1",
							"script": "DerivedColumn1 alterRow(insertIf(not(isNull(DimID)))) ~> AlterRow1"
						},
						{
							"name": "Select2",
							"script": "AlterRow1 select(mapColumn(\n\t\tTermCode,\n\t\tTermName = DimName,\n\t\tTermDescription = DimDescription,\n\t\tTermPreferred = DimPreferred,\n\t\tAvailable = SetAvailable@Available,\n\t\tTermTypeID = PossibleTypeID\n\t))~> Select2"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/PortDimsUpdateBranchTesting')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "MergePortfolioDims"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "PortfolioDimensionTables",
								"type": "DatasetReference"
							},
							"name": "PortfolioDimensionTables",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimTableName as string,\n\t\tDimID as integer,\n\t\tDimCode as string,\n\t\tDimName as string,\n\t\tDimDescription as string,\n\t\tDimActive as boolean\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PortfolioDimensionTables"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyDimensionTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyDimensionTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermDimTable as string,\n\t\tTermID as integer,\n\t\tTermDimID as long,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tTermAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyDimensionTerms"
						},
						{
							"dataset": {
								"referenceName": "CreateTurasDimsLookup",
								"type": "DatasetReference"
							},
							"name": "LookupType",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tDimTable as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LookupType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "IntermediateTermTable",
								"type": "DatasetReference"
							},
							"name": "UpdateSink",
							"script": "MarkForUpdate sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermID'],\n\tmapColumn(\n\t\tTermID,\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred = TermPreferred,\n\t\tAvailable = TermAvailable,\n\t\tTermTypeID\n\t)) ~> UpdateSink"
						}
					],
					"transformations": [
						{
							"name": "MergeJoin",
							"script": "PortfolioDimensionTables, TaxonomyDimensionTerms join(DimID == TermDimID\n\t&& DimTableName == TermDimTable,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit",
							"script": "Filter1 split(not(isNull(TermID)),\n\tdisjoint: true) ~> ConditionalSplit@(Update, Default)"
						},
						{
							"name": "SelectForUpdate",
							"script": "ConditionalSplit@Update select(mapColumn(\n\t\tDimID,\n\t\tTermID,\n\t\tTermCode,\n\t\tTermName,\n\t\tTermDescription,\n\t\tTermPreferred,\n\t\tTermAvailable,\n\t\tTermTypeID\n\t))~> SelectForUpdate"
						},
						{
							"name": "MarkForUpdate",
							"script": "SelectForUpdate alterRow(updateIf(not(isNull(TermID)))) ~> MarkForUpdate"
						},
						{
							"name": "Filter1",
							"script": "MergeJoin filter(DimID == 4303) ~> Filter1"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/UpdateTableTesting')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This is the Create Terms dataflow and include lookups to the TermTypeTable in the Taxonomy db.",
				"folder": {
					"name": "CreateTerms"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ThesaurusTerms",
								"type": "DatasetReference"
							},
							"name": "ThesaurusTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimID as integer,\n\t\tDimName as string,\n\t\tRootID as integer,\n\t\tDimPreferred as boolean,\n\t\tDimSourceID as integer,\n\t\tDimDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> ThesaurusTerms"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermID as integer,\n\t\tTermDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyTerms"
						},
						{
							"dataset": {
								"referenceName": "TermType",
								"type": "DatasetReference"
							},
							"name": "TermTypes",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TermTypes"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "sink1",
							"script": "SelectForInsertion sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermID'],\n\tmapColumn(\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred,\n\t\tDimID,\n\t\tAvailable,\n\t\tTermTypeID,\n\t\tTermID\n\t)) ~> sink1"
						}
					],
					"transformations": [
						{
							"name": "ConvertDimIDToTypeID",
							"script": "ThesaurusTerms derive(PossibleTypeID = toShort(DimID)) ~> ConvertDimIDToTypeID"
						},
						{
							"name": "LookupTypesWithDimID",
							"script": "ConvertDimIDToTypeID, TermTypes join(DimName == TypeName\n\t&& DimSourceID == SourceID\n\t&& PossibleTypeID == TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupTypesWithDimID"
						},
						{
							"name": "MergeJoin",
							"script": "Select1, TaxonomyTerms join(DimID == TermDimID,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit1",
							"script": "Filter1 split(not(isNull(TermID)),\n\tdisjoint: false) ~> ConditionalSplit1@(Update, Default)"
						},
						{
							"name": "ConvertNameAndDesc",
							"script": "ConditionalSplit1@Update derive(DimTypeName = left(DimName, 80),\n\t\tDimTypeDescription = left(DimDescription, 500)) ~> ConvertNameAndDesc"
						},
						{
							"name": "Select1",
							"script": "LookupTypesWithDimID select(mapColumn(\n\t\tDimID,\n\t\tRootID,\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tDimSourceID\n\t))~> Select1"
						},
						{
							"name": "SelectForInsertion",
							"script": "DerivedColumn1 select(mapColumn(\n\t\tDimPreferred,\n\t\tTermDescription,\n\t\tTermName,\n\t\tTermCode,\n\t\tDimID = TermDimID,\n\t\tAvailable,\n\t\tTermTypeID,\n\t\tPreferred = TermPreferred,\n\t\tTermID\n\t))~> SelectForInsertion"
						},
						{
							"name": "AlterRow2",
							"script": "ConvertNameAndDesc alterRow(updateIf(TermID==286337)) ~> AlterRow2"
						},
						{
							"name": "Filter1",
							"script": "MergeJoin filter(TermID == 286337) ~> Filter1"
						},
						{
							"name": "DerivedColumn1",
							"script": "AlterRow2 derive(DimTypeName = TermName,\n\t\tDimTypeDescription = DimDescription,\n\t\tDimPreferred = DimPreferred) ~> DerivedColumn1"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/dataflow1')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This is the Create Terms dataflow and include lookups to the TermTypeTable in the Taxonomy db.",
				"folder": {
					"name": "CreateTerms"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ThesaurusTerms",
								"type": "DatasetReference"
							},
							"name": "ThesaurusTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimID as integer,\n\t\tDimName as string,\n\t\tRootID as integer,\n\t\tDimPreferred as boolean,\n\t\tDimSourceID as integer,\n\t\tDimDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> ThesaurusTerms"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermID as integer,\n\t\tTermDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyTerms"
						},
						{
							"dataset": {
								"referenceName": "TermType",
								"type": "DatasetReference"
							},
							"name": "TermTypes",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TermTypes"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "UpdateSink",
							"script": "SelectForUpdate sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermID'],\n\tmapColumn(\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred = DimPreferred,\n\t\tDimID,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> UpdateSink"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "DeleteSink",
							"script": "Filter2 sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tmapColumn(\n\t\tTermID,\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = DimDescription,\n\t\tPreferred = DimPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> DeleteSink"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "InsertSink",
							"script": "AlterRow4 sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['DimID'],\n\tmapColumn(\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription,\n\t\tPreferred = DimPreferred,\n\t\tAvailable = SetAvailable@Available,\n\t\tTermTypeID = TaxonomyTerms@TermTypeID\n\t)) ~> InsertSink"
						}
					],
					"transformations": [
						{
							"name": "ConvertDimIDToTypeID",
							"script": "ThesaurusTerms derive(PossibleTypeID = toShort(DimID)) ~> ConvertDimIDToTypeID"
						},
						{
							"name": "LookupTypesWithDimID",
							"script": "ConvertDimIDToTypeID, TermTypes join(DimName == TypeName\n\t&& DimSourceID == SourceID\n\t&& PossibleTypeID == TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupTypesWithDimID"
						},
						{
							"name": "MergeJoin",
							"script": "Select1, TaxonomyTerms join(DimID == TermDimID,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "Select1",
							"script": "LookupTypesWithDimID select(mapColumn(\n\t\tDimID,\n\t\tRootID,\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tDimSourceID\n\t))~> Select1"
						},
						{
							"name": "SelectForUpdate",
							"script": "UpdateColumns select(mapColumn(\n\t\tDimPreferred,\n\t\tTermDescription,\n\t\tTermName,\n\t\tTermCode,\n\t\tDimID,\n\t\tAvailable,\n\t\tTermTypeID\n\t))~> SelectForUpdate"
						},
						{
							"name": "Filter1",
							"script": "MergeJoin filter(TermID == 286337) ~> Filter1"
						},
						{
							"name": "ConvertNameAndDesc",
							"script": "Filter1 derive(DimTypeName = left(DimName, 80),\n\t\tDimTypeDescription = left(DimDescription, 500)) ~> ConvertNameAndDesc"
						},
						{
							"name": "AlterRow3",
							"script": "ConvertNameAndDesc alterRow(updateIf(not(isNull(TermID)))) ~> AlterRow3"
						},
						{
							"name": "InsertBranch",
							"script": "MergeJoin filter(isNull(TermID)) ~> InsertBranch"
						},
						{
							"name": "AddAvailableColumn",
							"script": "DeleteBranchFilter derive(Available = true()) ~> AddAvailableColumn"
						},
						{
							"name": "Delete",
							"script": "AddAvailableColumn alterRow(updateIf(isNull(DimID))) ~> Delete"
						},
						{
							"name": "DerivedColumn1",
							"script": "Delete derive(Available = false()) ~> DerivedColumn1"
						},
						{
							"name": "UpdateColumns",
							"script": "AlterRow3 derive(TermName = DimName,\n\t\tDimDescription = DimDescription,\n\t\tDimPreferred = DimPreferred) ~> UpdateColumns"
						},
						{
							"name": "Filter2",
							"script": "DerivedColumn1 filter(isNull(DimID)) ~> Filter2"
						},
						{
							"name": "SetAvailable",
							"script": "InsertBranch derive(Available = true(),\n\t\tRootTypeID = toShort(RootID)) ~> SetAvailable"
						},
						{
							"name": "Join1",
							"script": "SetAvailable, TermTypes join(RootTypeID == TermTypes@TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> Join1"
						},
						{
							"name": "AlterRow4",
							"script": "Join1 alterRow(insertIf(isNull(TermID))) ~> AlterRow4"
						},
						{
							"name": "DeleteBranchFilter",
							"script": "MergeJoin filter(TermID == 286337) ~> DeleteBranchFilter"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_CreateRelationships')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "GetDimRelationship",
								"type": "DatasetReference"
							},
							"name": "GetDimRelationship",
							"typeProperties": {},
							"script": "source(output(\n\t\tXDimID as integer,\n\t\tYDimID as integer,\n\t\tDimKindID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> GetDimRelationship"
						},
						{
							"dataset": {
								"referenceName": "TermRelationship",
								"type": "DatasetReference"
							},
							"name": "TermRelationships",
							"typeProperties": {},
							"script": "source(output(\n\t\tRelationshipID as integer,\n\t\tXTermID as integer,\n\t\tXTermDimID as integer,\n\t\tYTermID as integer,\n\t\tYTermDimID as integer,\n\t\tTermKindID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TermRelationships"
						},
						{
							"dataset": {
								"referenceName": "ds_CreateLookupTable",
								"type": "DatasetReference"
							},
							"name": "LookupTable",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermID as integer,\n\t\tDimID as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT Term.TermID, Term.DimID FROM dbo.intermediateTerm Term',\n\tformat: 'query') ~> LookupTable"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TermRelationshipSink",
								"type": "DatasetReference"
							},
							"name": "InsertRelationship",
							"script": "Filter2 sink(input(\n\t\tRelationshipID as integer,\n\t\tTermXID as integer,\n\t\tTermYID as integer,\n\t\tKindID as integer,\n\t\tDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tmapColumn(\n\t\tTermXID = XTermID,\n\t\tTermYID = YTermID,\n\t\tKindID = DimKindID\n\t)) ~> InsertRelationship"
						},
						{
							"dataset": {
								"referenceName": "TermRelationshipSink",
								"type": "DatasetReference"
							},
							"name": "DeleteRelationship",
							"script": "MarkForDeletion sink(input(\n\t\tRelationshipID as integer,\n\t\tTermXID as integer,\n\t\tTermYID as integer,\n\t\tKindID as integer,\n\t\tDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['RelationshipID'],\n\tmapColumn(\n\t\tRelationshipID,\n\t\tTermXID = XTermID,\n\t\tTermYID = YTermID,\n\t\tKindID = DimKindID\n\t)) ~> DeleteRelationship"
						}
					],
					"transformations": [
						{
							"name": "MergeJoin",
							"script": "GetDimRelationship, TermRelationships join(XDimID == XTermDimID\n\t&& YDimID == YTermDimID\n\t&& DimKindID == TermKindID,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit",
							"script": "MergeJoin split(isNull(XTermID),\n\tisNull(XDimID),\n\tdisjoint: true) ~> ConditionalSplit@(Insert, Delete, UpdateDoNothing)"
						},
						{
							"name": "Select1",
							"script": "LookupXTerm select(mapColumn(\n\t\tYDimID,\n\t\tDimKindID,\n\t\tRelationshipID,\n\t\tXTermID = TermID,\n\t\tYTermID\n\t))~> Select1"
						},
						{
							"name": "Select2",
							"script": "LookupYTerm select(mapColumn(\n\t\tDimKindID,\n\t\tXTermID,\n\t\tYTermID = TermID\n\t))~> Select2"
						},
						{
							"name": "LookupXTerm",
							"script": "ConditionalSplit@Insert, LookupTable join(XDimID == DimID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupXTerm"
						},
						{
							"name": "LookupYTerm",
							"script": "Select1, LookupTable join(YDimID == DimID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupYTerm"
						},
						{
							"name": "MarkForInsertion",
							"script": "Select2 alterRow(insertIf(not(isNull(XTermID)))) ~> MarkForInsertion"
						},
						{
							"name": "SelectForDeletion",
							"script": "ConditionalSplit@Delete select(mapColumn(\n\t\tXDimID,\n\t\tDimKindID,\n\t\tRelationshipID,\n\t\tXTermID,\n\t\tYTermID\n\t))~> SelectForDeletion"
						},
						{
							"name": "MarkForDeletion",
							"script": "SelectForDeletion alterRow(deleteIf(isNull(XDimID))) ~> MarkForDeletion"
						},
						{
							"name": "Filter2",
							"script": "MarkForInsertion filter(not(isNull(YTermID)) && not(isNull(XTermID))) ~> Filter2"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_CreateTerms')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "This is the Create Terms dataflow and include lookups to the TermTypeTable in the Taxonomy db.",
				"folder": {
					"name": "CreateTerms"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ThesaurusTerms",
								"type": "DatasetReference"
							},
							"name": "ThesaurusTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimID as integer,\n\t\tDimName as string,\n\t\tRootID as integer,\n\t\tDimPreferred as boolean,\n\t\tDimSourceID as integer,\n\t\tDimDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> ThesaurusTerms"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermID as integer,\n\t\tTermDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyTerms"
						},
						{
							"dataset": {
								"referenceName": "TermTypeSink",
								"type": "DatasetReference"
							},
							"name": "TermTypes",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TermTypes"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "TaxonomyTermsInsert",
							"script": "SelectForInsertion sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tmapColumn(\n\t\tDimID = TermTypeID,\n\t\tTermCode,\n\t\tTermName = DimName,\n\t\tDescription = DimDescription,\n\t\tPreferred = DimPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> TaxonomyTermsInsert"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "DeleteSink",
							"script": "SelectForDelete sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['DimID'],\n\tmapColumn(\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred = DimPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> DeleteSink"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyTermsInsert",
								"type": "DatasetReference"
							},
							"name": "UpdateTerm",
							"script": "SelectForUpdate sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermID'],\n\tmapColumn(\n\t\tTermID,\n\t\tDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tPreferred = DimPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t)) ~> UpdateTerm"
						}
					],
					"transformations": [
						{
							"name": "ConvertDimIDToTypeID",
							"script": "ThesaurusTerms derive(PossibleTypeID = toShort(DimID)) ~> ConvertDimIDToTypeID"
						},
						{
							"name": "LookupTypesWithDimID",
							"script": "ConvertDimIDToTypeID, TermTypes join(DimName == TypeName\n\t&& DimSourceID == SourceID\n\t&& PossibleTypeID == TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupTypesWithDimID"
						},
						{
							"name": "MergeJoin",
							"script": "SelectFromLookup, TaxonomyTerms join(DimID == TermDimID,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit1",
							"script": "MergeJoin split(isNull(TermID),\n\tisNull(DimID),\n\tnot(isNull(TermID)),\n\tdisjoint: true) ~> ConditionalSplit1@(Insert, Delete, Update, Default)"
						},
						{
							"name": "SetAvailable",
							"script": "ConditionalSplit1@Insert derive(Available = true(),\n\t\tRootTypeID = toShort(RootID)) ~> SetAvailable"
						},
						{
							"name": "LookupTypeWithRootID",
							"script": "SetAvailable, TermTypes join(RootID == TermTypes@TermTypeID,\n\tjoinType:'inner',\n\tbroadcast: 'none')~> LookupTypeWithRootID"
						},
						{
							"name": "SelectFromLookup",
							"script": "LookupTypesWithDimID select(mapColumn(\n\t\tDimID,\n\t\tRootID,\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tDimSourceID\n\t))~> SelectFromLookup"
						},
						{
							"name": "ConditionsForInsertion",
							"script": "LookupTypeWithRootID alterRow(insertIf(not(isNull(DimID)))) ~> ConditionsForInsertion"
						},
						{
							"name": "SelectForInsertion",
							"script": "ConditionsForInsertion select(mapColumn(\n\t\tDimPreferred,\n\t\tDimDescription,\n\t\tPossibleTypeID,\n\t\tDimName,\n\t\tTermCode,\n\t\tAvailable = SetAvailable@Available,\n\t\tTermTypeID = PossibleTypeID\n\t))~> SelectForInsertion"
						},
						{
							"name": "ConditionsForDelete",
							"script": "ConditionalSplit1@Delete alterRow(updateIf(TermID==286337)) ~> ConditionsForDelete"
						},
						{
							"name": "SelectForDelete",
							"script": "DerivedColumn1 select(mapColumn(\n\t\tDimPreferred,\n\t\tDimID = TermDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tTermDescription,\n\t\tTermPreferred,\n\t\tAvailable,\n\t\tTermTypeID\n\t))~> SelectForDelete"
						},
						{
							"name": "DerivedColumn1",
							"script": "ConditionsForDelete derive(Available = false()) ~> DerivedColumn1"
						},
						{
							"name": "ConvertNameAndDesc",
							"script": "ConditionalSplit1@Update derive(DimTypeName = left(DimName, 80),\n\t\tDimTypeDescription = left(DimDescription, 500)) ~> ConvertNameAndDesc"
						},
						{
							"name": "ConditionsForUpdate",
							"script": "ConvertNameAndDesc alterRow(updateIf(not(isNull(TermID)))) ~> ConditionsForUpdate"
						},
						{
							"name": "SelectForUpdate",
							"script": "DerivedColumn2 select(mapColumn(\n\t\tDimPreferred,\n\t\tDimID = TermDimID,\n\t\tTermCode,\n\t\tTermName,\n\t\tTermDescription,\n\t\tTermPreferred,\n\t\tAvailable,\n\t\tTermTypeID,\n\t\tTermID\n\t))~> SelectForUpdate"
						},
						{
							"name": "DerivedColumn2",
							"script": "ConditionsForUpdate derive(DimTypeName = TermName,\n\t\tDimTypeDescription = DimDescription,\n\t\tDimPreferred = DimPreferred) ~> DerivedColumn2"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_DeleteTermRelationships')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "TermRelationshipSink",
								"type": "DatasetReference"
							},
							"name": "TermRelationships",
							"typeProperties": {},
							"script": "source(output(\n\t\tRelationshipID as integer,\n\t\tTermXID as integer,\n\t\tTermYID as integer,\n\t\tKindID as integer,\n\t\tDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TermRelationships"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TermRelationshipSink",
								"type": "DatasetReference"
							},
							"name": "DeleteSink",
							"script": "DelIfTermYIDIsNull sink(input(\n\t\tRelationshipID as integer,\n\t\tTermXID as integer,\n\t\tTermYID as integer,\n\t\tKindID as integer,\n\t\tDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['RelationshipID']) ~> DeleteSink"
						}
					],
					"transformations": [
						{
							"name": "DelIfTermXIDIsNull",
							"script": "TermRelationships alterRow(deleteIf(isNull(TermXID))) ~> DelIfTermXIDIsNull"
						},
						{
							"name": "DelIfTermYIDIsNull",
							"script": "DelIfTermXIDIsNull alterRow(deleteIf(isNull(TermYID))) ~> DelIfTermYIDIsNull"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_MergePortfolioDimensions')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "MergePortfolioDims"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "PortfolioDimensionTables",
								"type": "DatasetReference"
							},
							"name": "PortfolioDimensionTables",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimTableName as string,\n\t\tDimID as integer,\n\t\tDimCode as string,\n\t\tDimName as string,\n\t\tDimDescription as string,\n\t\tDimActive as boolean\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PortfolioDimensionTables"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyDimensionTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyDimensionTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermDimTable as string,\n\t\tTermID as integer,\n\t\tTermDimID as long,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tTermAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyDimensionTerms"
						},
						{
							"dataset": {
								"referenceName": "CreateTurasDimsLookup",
								"type": "DatasetReference"
							},
							"name": "LookupType",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tDimTable as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LookupType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "IntermediateTermTable",
								"type": "DatasetReference"
							},
							"name": "SinkIntoTermTaxonomy",
							"script": "RemoveNullTermTypeID sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tmapColumn(\n\t\tDimID,\n\t\tTermCode = DimCode,\n\t\tTermName = DimName,\n\t\tDescription = DimDescription,\n\t\tPreferred,\n\t\tAvailable = DimActive,\n\t\tTermTypeID = TermTypeID_LookUp\n\t)) ~> SinkIntoTermTaxonomy"
						},
						{
							"dataset": {
								"referenceName": "IntermediateTermTable",
								"type": "DatasetReference"
							},
							"name": "DeleteTerm",
							"script": "MarkForDeletion sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['TermID']) ~> DeleteTerm"
						},
						{
							"dataset": {
								"referenceName": "IntermediateTermTable",
								"type": "DatasetReference"
							},
							"name": "UpdateSink",
							"script": "MarkForUpdate sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermID'],\n\tmapColumn(\n\t\tTermID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tAvailable = TermAvailable,\n\t\tDimID,\n\t\tPreferred = TermPreferred,\n\t\tTermTypeID\n\t)) ~> UpdateSink"
						}
					],
					"transformations": [
						{
							"name": "MergeJoin",
							"script": "PortfolioDimensionTables, TaxonomyDimensionTerms join(DimID == TermDimID\n\t&& DimTableName == TermDimTable,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit",
							"script": "MergeJoin split(isNull(TermID),\n\tisNull(DimID),\n\tdisjoint: true) ~> ConditionalSplit@(Insert, Delete, Update)"
						},
						{
							"name": "DerivedColumn",
							"script": "ConditionalSplit@Insert derive(Preferred = true()) ~> DerivedColumn"
						},
						{
							"name": "Lookup1",
							"script": "DerivedColumn, LookupType lookup(DimTableName == DimTable,\n\tbroadcast: 'none')~> Lookup1"
						},
						{
							"name": "SelectForInsertion",
							"script": "Lookup1 select(mapColumn(\n\t\tDimID,\n\t\tDimCode,\n\t\tDimName,\n\t\tDimDescription,\n\t\tDimActive,\n\t\tTermID,\n\t\tPreferred,\n\t\tTermTypeID_LookUp = LookupType@TermTypeID\n\t))~> SelectForInsertion"
						},
						{
							"name": "SelectForDeletion",
							"script": "ConditionalSplit@Delete select(mapColumn(\n\t\tDimID,\n\t\tTermID,\n\t\tTermCode,\n\t\tTermName\n\t))~> SelectForDeletion"
						},
						{
							"name": "MarkForDeletion",
							"script": "SelectForDeletion alterRow(deleteIf(isNull(DimID))) ~> MarkForDeletion"
						},
						{
							"name": "SelectForUpdate",
							"script": "ConditionalSplit@Update select(mapColumn(\n\t\tDimID,\n\t\tTermID,\n\t\tTermCode,\n\t\tTermName,\n\t\tTermDescription,\n\t\tTermPreferred,\n\t\tTermAvailable,\n\t\tTermTypeID\n\t))~> SelectForUpdate"
						},
						{
							"name": "MarkForUpdate",
							"script": "SelectForUpdate alterRow(updateIf(not(isNull(TermID)))) ~> MarkForUpdate"
						},
						{
							"name": "AlterRow1",
							"script": "SelectForInsertion alterRow(insertIf(not(isNull(TermTypeID_LookUp)))) ~> AlterRow1"
						},
						{
							"name": "RemoveNullTermTypeID",
							"script": "AlterRow1 filter(not(isNull(TermTypeID_LookUp))) ~> RemoveNullTermTypeID"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_PortThesaurusTerms')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "TermTable",
								"type": "DatasetReference"
							},
							"name": "GetThesaurusTypes",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimID as integer,\n\t\tDimName as string,\n\t\tDimDescription as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> GetThesaurusTypes"
						},
						{
							"dataset": {
								"referenceName": "AzureSqlTermTypes",
								"type": "DatasetReference"
							},
							"name": "GetTaxonomyTermTypes",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tTypeDescription as string,\n\t\tTypeAvailable as boolean,\n\t\tTypeSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> GetTaxonomyTermTypes"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "TermTypeSink",
								"type": "DatasetReference"
							},
							"name": "InsertSink",
							"script": "AssignForInsertion sink(input(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['TermTypeID'],\n\tmapColumn(\n\t\tTermTypeID,\n\t\tTypeName,\n\t\tDescription = TypeDescription,\n\t\tAvailable = TypeAvailable,\n\t\tSourceID = DimSourceID\n\t)) ~> InsertSink"
						},
						{
							"dataset": {
								"referenceName": "TermTypeSink",
								"type": "DatasetReference"
							},
							"name": "UpdateSink",
							"script": "Filter1 sink(input(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermTypeID'],\n\tmapColumn(\n\t\tTermTypeID,\n\t\tTypeName,\n\t\tDescription = TypeDescription\n\t),\n\tdateFormat:'dd/MM/yyyy') ~> UpdateSink"
						},
						{
							"dataset": {
								"referenceName": "TermTypeSink",
								"type": "DatasetReference"
							},
							"name": "DeleteSink",
							"script": "TermTypeSoftDelete sink(input(\n\t\tTermTypeID as integer,\n\t\tTypeName as string,\n\t\tDescription as string,\n\t\tAvailable as boolean,\n\t\tDimTable as string,\n\t\tSourceID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermTypeID'],\n\tmapColumn(\n\t\tTermTypeID,\n\t\tTypeName,\n\t\tDescription,\n\t\tAvailable = TypeAvailable,\n\t\tSourceID = TypeSourceID\n\t)) ~> DeleteSink"
						},
						{
							"dataset": {
								"referenceName": "TermSINK",
								"type": "DatasetReference"
							},
							"name": "MarkTermsOfThisTypeAlsoUnavailable",
							"script": "Filter2 sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermTypeID'],\n\tmapColumn(\n\t\tTermTypeID,\n\t\tTermName = TypeName,\n\t\tDescription = TypeDescription,\n\t\tAvailable = TypeAvailable\n\t)) ~> MarkTermsOfThisTypeAlsoUnavailable"
						}
					],
					"transformations": [
						{
							"name": "MergeJoin",
							"script": "GetThesaurusTypes, GetTaxonomyTermTypes join(DimID == TermTypeID,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit1",
							"script": "MergeJoin split(isNull(TermTypeID),\n\tisNull(DimID),\n\tdisjoint: true) ~> ConditionalSplit1@(insert, delete, update)"
						},
						{
							"name": "ConvertDimToType",
							"script": "ConditionalSplit1@insert derive(DimAvailable = true(),\n\t\tDimSourceID = 2,\n\t\tDimTypeName = left(DimName, 80),\n\t\tDimTypeDescription = left(DimDescription, 500)) ~> ConvertDimToType"
						},
						{
							"name": "SelectColumnsToInsert",
							"script": "ConvertDimToType select(mapColumn(\n\t\tTermTypeID = DimID,\n\t\tTypeName = DimTypeName,\n\t\tTypeDescription = DimTypeDescription,\n\t\tTypeAvailable = DimAvailable,\n\t\tDimSourceID\n\t))~> SelectColumnsToInsert"
						},
						{
							"name": "ConvertNameAndDesc",
							"script": "ConditionalSplit1@update derive(DimTypeName = left(DimName, 80),\n\t\tDimTypeDescription = left(DimDescription, 500)) ~> ConvertNameAndDesc"
						},
						{
							"name": "SelectForUpdate",
							"script": "ConditionForUpdate select(mapColumn(\n\t\tTermTypeID,\n\t\tTypeName = DimTypeName,\n\t\tTypeDescription = DimTypeDescription\n\t))~> SelectForUpdate"
						},
						{
							"name": "ConditionForUpdate",
							"script": "ConvertNameAndDesc alterRow(updateIf(not(isNull(TermTypeID)))) ~> ConditionForUpdate"
						},
						{
							"name": "ConditionForDelete",
							"script": "ConditionalSplit1@delete alterRow(updateIf(not(isNull(TermTypeID)))) ~> ConditionForDelete"
						},
						{
							"name": "TermTypeSoftDelete",
							"script": "SelectValueToModify select(mapColumn(\n\t\tTermTypeID,\n\t\tTypeName,\n\t\tTypeAvailable,\n\t\tTypeSourceID,\n\t\tDescription = TypeDescription\n\t))~> TermTypeSoftDelete"
						},
						{
							"name": "SelectValueToModify",
							"script": "ConditionForDelete derive(TypeAvailable = TypeAvailable == false()) ~> SelectValueToModify"
						},
						{
							"name": "SoftDeleteTermTable",
							"script": "SelectValueToModify select(mapColumn(\n\t\tTermTypeID,\n\t\tTypeName,\n\t\tTypeDescription,\n\t\tTypeAvailable\n\t))~> SoftDeleteTermTable"
						},
						{
							"name": "AssignForInsertion",
							"script": "SelectColumnsToInsert alterRow(insertIf(not(isNull(TermTypeID)))) ~> AssignForInsertion"
						},
						{
							"name": "Filter1",
							"script": "SelectForUpdate filter(not(isNull(TermTypeID)) && not(isNull(TypeName))) ~> Filter1"
						},
						{
							"name": "Filter2",
							"script": "SoftDeleteTermTable filter(not(isNull(TermTypeID))) ~> Filter2"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/insertBranchTesting')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "MergePortfolioDims"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "PortfolioDimensionTables",
								"type": "DatasetReference"
							},
							"name": "PortfolioDimensionTables",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimTableName as string,\n\t\tDimID as integer,\n\t\tDimCode as string,\n\t\tDimName as string,\n\t\tDimDescription as string,\n\t\tDimActive as boolean\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> PortfolioDimensionTables"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyDimensionTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyDimensionTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermDimTable as string,\n\t\tTermID as integer,\n\t\tTermDimID as long,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tTermAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyDimensionTerms"
						},
						{
							"dataset": {
								"referenceName": "CreateTurasDimsLookup",
								"type": "DatasetReference"
							},
							"name": "LookupType",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tDimTable as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LookupType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "IntermediateTermTable",
								"type": "DatasetReference"
							},
							"name": "SinkIntoTermTaxonomy",
							"script": "Filter2 sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tmapColumn(\n\t\tDimID,\n\t\tTermCode = DimCode,\n\t\tTermName = DimName,\n\t\tDescription = DimDescription,\n\t\tPreferred,\n\t\tAvailable = DimActive,\n\t\tTermTypeID = TermTypeID_LookUp\n\t)) ~> SinkIntoTermTaxonomy"
						}
					],
					"transformations": [
						{
							"name": "MergeJoin",
							"script": "PortfolioDimensionTables, TaxonomyDimensionTerms join(DimID == TermDimID\n\t&& DimTableName == TermDimTable,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "AddPreferredColumn",
							"script": "ConditionalSplit1@Insert derive(Preferred = true()) ~> AddPreferredColumn"
						},
						{
							"name": "Lookup1",
							"script": "AddPreferredColumn, LookupType lookup(DimTableName == DimTable,\n\tbroadcast: 'none')~> Lookup1"
						},
						{
							"name": "SelectForInsertion",
							"script": "Lookup1 select(mapColumn(\n\t\tDimID,\n\t\tDimCode,\n\t\tDimName,\n\t\tDimDescription,\n\t\tDimActive,\n\t\tTermID,\n\t\tPreferred,\n\t\tTermTypeID_LookUp = LookupType@TermTypeID\n\t))~> SelectForInsertion"
						},
						{
							"name": "AlterRow1",
							"script": "SelectForInsertion alterRow(insertIf(not(isNull(TermTypeID_LookUp)))) ~> AlterRow1"
						},
						{
							"name": "Filter2",
							"script": "AlterRow1 filter(not(isNull(TermTypeID_LookUp))) ~> Filter2"
						},
						{
							"name": "ConditionalSplit1",
							"script": "MergeJoin split(isNull(TermID),\n\tdisjoint: false) ~> ConditionalSplit1@(Insert, Default)"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/df_MergeTurasDimensions')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"folder": {
					"name": "MergePortfolioDims"
				},
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DestinationTurasDimensions",
								"type": "DatasetReference"
							},
							"name": "TurasDimensionTables",
							"typeProperties": {},
							"script": "source(output(\n\t\tDimTableName as string,\n\t\tDimID as long,\n\t\tDimCode as string,\n\t\tDimName as string,\n\t\tDimDescription as string,\n\t\tDimActive as boolean\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TurasDimensionTables"
						},
						{
							"dataset": {
								"referenceName": "TaxonomyDimensionTerms",
								"type": "DatasetReference"
							},
							"name": "TaxonomyDimensionTerms",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermDimTable as string,\n\t\tTermID as integer,\n\t\tTermDimID as long,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tTermDescription as string,\n\t\tTermPreferred as boolean,\n\t\tTermAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> TaxonomyDimensionTerms"
						},
						{
							"dataset": {
								"referenceName": "CreateTurasDimsLookup",
								"type": "DatasetReference"
							},
							"name": "LookupType",
							"typeProperties": {},
							"script": "source(output(\n\t\tTermTypeID as integer,\n\t\tDimTable as string\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> LookupType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "IntermediateTermTable",
								"type": "DatasetReference"
							},
							"name": "SinkIntoTermTaxonomy",
							"script": "RemoveNullTermTypeID sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tmapColumn(\n\t\tDimID,\n\t\tTermCode = DimCode,\n\t\tTermName = DimName,\n\t\tDescription = DimDescription,\n\t\tPreferred,\n\t\tAvailable = DimActive,\n\t\tTermTypeID = TermTypeID_LookUp\n\t)) ~> SinkIntoTermTaxonomy"
						},
						{
							"dataset": {
								"referenceName": "IntermediateTermTable",
								"type": "DatasetReference"
							},
							"name": "DeleteTerm",
							"script": "MarkForDeletion sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['TermID']) ~> DeleteTerm"
						},
						{
							"dataset": {
								"referenceName": "IntermediateTermTable",
								"type": "DatasetReference"
							},
							"name": "UpdateSink",
							"script": "MarkForUpdate sink(input(\n\t\tTermID as integer,\n\t\tDimID as integer,\n\t\tTermCode as string,\n\t\tTermName as string,\n\t\tDescription as string,\n\t\tPreferred as boolean,\n\t\tAvailable as boolean,\n\t\tTermTypeID as integer\n\t),\n\tallowSchemaDrift: false,\n\tvalidateSchema: false,\n\tformat: 'table',\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['TermID'],\n\tmapColumn(\n\t\tTermID,\n\t\tTermCode,\n\t\tTermName,\n\t\tDescription = TermDescription,\n\t\tAvailable = TermAvailable,\n\t\tDimID,\n\t\tPreferred = TermPreferred,\n\t\tTermTypeID\n\t)) ~> UpdateSink"
						}
					],
					"transformations": [
						{
							"name": "MergeJoin",
							"script": "TurasDimensionTables, TaxonomyDimensionTerms join(DimID == TermDimID\n\t&& DimTableName == TermDimTable,\n\tjoinType:'outer',\n\tbroadcast: 'none')~> MergeJoin"
						},
						{
							"name": "ConditionalSplit",
							"script": "MergeJoin split(isNull(TermID),\n\tisNull(DimID),\n\tdisjoint: true) ~> ConditionalSplit@(Insert, Delete, Update)"
						},
						{
							"name": "DerivedColumn",
							"script": "ConditionalSplit@Insert derive(Preferred = true()) ~> DerivedColumn"
						},
						{
							"name": "Lookup1",
							"script": "DerivedColumn, LookupType lookup(DimTableName == DimTable,\n\tbroadcast: 'none')~> Lookup1"
						},
						{
							"name": "SelectForInsertion",
							"script": "Lookup1 select(mapColumn(\n\t\tDimID,\n\t\tDimCode,\n\t\tDimName,\n\t\tDimDescription,\n\t\tDimActive,\n\t\tTermID,\n\t\tPreferred,\n\t\tTermTypeID_LookUp = LookupType@TermTypeID\n\t))~> SelectForInsertion"
						},
						{
							"name": "SelectForDeletion",
							"script": "ConditionalSplit@Delete select(mapColumn(\n\t\tDimID,\n\t\tTermID,\n\t\tTermCode,\n\t\tTermName\n\t))~> SelectForDeletion"
						},
						{
							"name": "MarkForDeletion",
							"script": "SelectForDeletion alterRow(deleteIf(isNull(DimID))) ~> MarkForDeletion"
						},
						{
							"name": "SelectForUpdate",
							"script": "ConditionalSplit@Update select(mapColumn(\n\t\tDimID,\n\t\tTermID,\n\t\tTermCode,\n\t\tTermName,\n\t\tTermDescription,\n\t\tTermPreferred,\n\t\tTermAvailable,\n\t\tTermTypeID\n\t))~> SelectForUpdate"
						},
						{
							"name": "MarkForUpdate",
							"script": "SelectForUpdate alterRow(updateIf(not(isNull(TermID)))) ~> MarkForUpdate"
						},
						{
							"name": "AlterRow1",
							"script": "SelectForInsertion alterRow(insertIf(not(isNull(TermTypeID_LookUp)))) ~> AlterRow1"
						},
						{
							"name": "RemoveNullTermTypeID",
							"script": "AlterRow1 filter(not(isNull(TermTypeID_LookUp))) ~> RemoveNullTermTypeID"
						}
					]
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/CreateThesaurusTerms_Dim_Source')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Pipeline to create the Thesaurus Terms (Dim) Source dataset for use in the CreateTerms dataflow",
				"activities": [
					{
						"name": "CreateThesaurusTerms_Dim_SourceTable",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT DISTINCT CAST(Term.id AS BIGINT)  DimID, \n       CAST(Term.name AS NVARCHAR(200)) DimName, \n       dbo.GetRootParent(Term.id) RootID,\n       CAST(CASE ISNULL(Relation.relationship, 0)\n          WHEN 0 THEN 1\n          ELSE 0\n          END AS BIT) DimPreferred,\n       CAST(2 AS SMALLINT) DimSourceID,\n       CAST(RTRIM(Term.scope + ' ' + Term.additionalnotes) AS NVARCHAR(500)) DimDescription\n  from dbo.Term\n   LEFT JOIN dbo.Relation ON Relation.relatedtermid = Term.id AND Relation.relationship=2\n  ORDER BY DimID"
							},
							"sink": {
								"type": "AzureSqlSink"
							},
							"enableStaging": false
						},
						"inputs": [
							{
								"referenceName": "LocalTermsTableOnThesaurus",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "ThesaurusTerms_Dim_SourceOnAzure",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"folder": {
					"name": "CreateTerms"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/RunMergePortfolioDimensions')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_MergePortfolioDimensions",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_MergePortfolioDimensions",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"PortfolioDimensionTables": {},
									"TaxonomyDimensionTerms": {},
									"LookupType": {},
									"SinkIntoTermTaxonomy": {},
									"DeleteTerm": {},
									"UpdateSink": {}
								}
							},
							"staging": {}
						}
					},
					{
						"name": "UpsertToTermTable",
						"description": "Pipeline to upsert to the term table in the PortThesaurus DB",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "df_MergePortfolioDimensions",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource"
							},
							"sink": {
								"type": "AzureSqlSink",
								"sqlWriterStoredProcedureName": "[[dbo].[spUpsertTerm]",
								"sqlWriterTableType": "Term"
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "TermID",
											"type": "Int32"
										},
										"sink": {
											"name": "TermID",
											"type": "Int32"
										}
									},
									{
										"source": {
											"name": "DimID",
											"type": "Int32"
										},
										"sink": {
											"name": "DimID",
											"type": "Int32"
										}
									},
									{
										"source": {
											"name": "TermCode",
											"type": "String"
										},
										"sink": {
											"name": "TermCode",
											"type": "String"
										}
									},
									{
										"source": {
											"name": "TermName",
											"type": "String"
										},
										"sink": {
											"name": "TermName",
											"type": "String"
										}
									},
									{
										"source": {
											"name": "Description",
											"type": "String"
										},
										"sink": {
											"name": "Description",
											"type": "String"
										}
									},
									{
										"source": {
											"name": "Preferred",
											"type": "Boolean"
										},
										"sink": {
											"name": "Preferred",
											"type": "Boolean"
										}
									},
									{
										"source": {
											"name": "Available",
											"type": "Boolean"
										},
										"sink": {
											"name": "Available",
											"type": "Boolean"
										}
									},
									{
										"source": {
											"name": "TermTypeID",
											"type": "Int16"
										},
										"sink": {
											"name": "TermTypeID",
											"type": "Int16"
										}
									}
								]
							}
						},
						"inputs": [
							{
								"referenceName": "datasetIntermediateTermTable",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DestinationTermTable",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"folder": {
					"name": "MergePortfolioDimensions"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_MergePortfolioDimensions')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/RunMergePotfolioDimsOnly')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "df_MergePortfolioDimensions",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_MergePortfolioDimensions",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"PortfolioDimensionTables": {},
									"TaxonomyDimensionTerms": {},
									"LookupType": {},
									"SinkIntoTermTaxonomy": {},
									"DeleteTerm": {},
									"UpdateSink": {}
								}
							},
							"staging": {}
						}
					}
				],
				"folder": {
					"name": "MergePortfolioDimensions"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_MergePortfolioDimensions')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/RunMergeTurasDimensions')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "Run_MergeTurasDimensions",
						"type": "ExecuteDataFlow",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"dataflow": {
								"referenceName": "df_MergeTurasDimensions",
								"type": "DataFlowReference",
								"parameters": {},
								"datasetParameters": {
									"TurasDimensionTables": {},
									"TaxonomyDimensionTerms": {},
									"LookupType": {},
									"SinkIntoTermTaxonomy": {},
									"DeleteTerm": {},
									"UpdateSink": {}
								}
							},
							"staging": {}
						}
					}
				],
				"folder": {
					"name": "MergeTurasDimensions"
				},
				"annotations": []
			},
			"dependsOn": [
				"[concat(variables('factoryId'), '/dataflows/df_MergeTurasDimensions')]"
			]
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_CopyFromLocalToRelation')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Uses a query to create a table for use in the Create Relationships dataflow source table entitled 'Get Dim relationship'",
				"activities": [
					{
						"name": "CreateDimRelationship",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [
							{
								"name": "Destination",
								"value": "[[dbo].[GetDimRelationship]"
							}
						],
						"typeProperties": {
							"source": {
								"type": "SqlSource",
								"sqlReaderQuery": "SELECT maintermid XDimID, relatedtermid YDimID,\r\nCAST(CASE relationship\r\n  WHEN 1 THEN 2 -- synonym\r\n  WHEN 4 THEN 1 -- parent/child\r\n  WHEN 5 THEN 4 --association\r\n  END AS SMALLINT) DimKindID\r\nFROM dbo.Relation WHERE relationship IN (1, 4, 5) \r\nAND relatedtermid <> maintermid\r\nORDER BY XDimID, YDimID, DimKindID;"
							},
							"sink": {
								"type": "SqlSink",
								"writeBatchSize": 10000
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"columnMappings": {
									"XDimID": "XDimID",
									"YDimID": "YDimID",
									"DimKindID": "DimKindID"
								}
							}
						},
						"inputs": [
							{
								"referenceName": "SourceRelationFromLocal",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DestinationGetDimRelationship",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"folder": {
					"name": "CreateRelationships"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_CopyLocalToTermRelationships-old')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Uses a query to copy from the TermRelationship and Term table on the Taxonomy db.  Used in the Term relationships sink in the Create relationships dataflow.",
				"activities": [
					{
						"name": "CopyLocalToTermRelationships",
						"description": "Uses a query to create the TermRelationships table on the AzureDB",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [
							{
								"name": "Destination",
								"value": "[[dbo].[TermRelationships]"
							}
						],
						"typeProperties": {
							"source": {
								"type": "SqlSource",
								"sqlReaderQuery": "SELECT TermRelationship.RelationshipID, TermX.TermID XTermID, TermX.DimID XTermDimID,\r\n  TermY.TermID YTermID, TermY.DimID YTermDimID,\r\n  TermRelationship.KindID TermKindID\r\nFROM dbo.TermRelationship\r\n  LEFT JOIN dbo.Term TermX on TermX.TermID = TermRelationship.TermXID\r\n  LEFT JOIN dbo.Term TermY on TermY.TermID = TermRelationship.TermYID\r\n  LEFT JOIN dbo.TermType on TermType.TermTypeID = TermX.TermTypeID\r\nWHERE TermType.SourceID = 2\r\nORDER BY TermX.DimID, TermY.DimID, TermKindID;"
							},
							"sink": {
								"type": "SqlSink",
								"writeBatchSize": 10000
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"columnMappings": {
									"RelationshipID": "RelationshipID",
									"XTermID": "XTermID",
									"XTermDimID": "XTermDimID",
									"YTermID": "YTermID",
									"YTermDimID": "YTermDimID",
									"TermKindID": "TermKindID"
								}
							}
						},
						"inputs": [
							{
								"referenceName": "SourceLocalToTermRelationships",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DestinationTermRelationships",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"folder": {
					"name": "CreateRelationships"
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_CopyLocalToTermTypeSource')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Copy the contents of the TermType table on the local db to the TermTypeSource table on Azure. ",
				"activities": [
					{
						"name": "CopyLocalToTermTypeSource",
						"type": "Copy",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [
							{
								"name": "Destination",
								"value": "[[dbo].[TermTypeSOURCE]"
							}
						],
						"typeProperties": {
							"source": {
								"type": "SqlServerSource",
								"sqlReaderQuery": "SELECT TermTypeID, TypeName, Description TypeDescription, Available TypeAvailable, SourceID TypeSourceID FROM dbo.TermType WHERE SourceID = 2"
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBatchSize": 10000
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"name": "TermTypeID",
											"type": "Int16"
										},
										"sink": {
											"name": "TermTypeID",
											"type": "Int16"
										}
									},
									{
										"source": {
											"name": "TypeName",
											"type": "String"
										},
										"sink": {
											"name": "TypeName",
											"type": "String"
										}
									},
									{
										"source": {
											"name": "TypeDescription",
											"type": "String"
										},
										"sink": {
											"name": "TypeDescription",
											"type": "String"
										}
									},
									{
										"source": {
											"name": "TypeAvailable",
											"type": "Boolean"
										},
										"sink": {
											"name": "TypeAvailable",
											"type": "Boolean"
										}
									},
									{
										"source": {
											"name": "TypeSourceID",
											"type": "Int16"
										},
										"sink": {
											"name": "TypeSourceID",
											"type": "Int16"
										}
									}
								]
							}
						},
						"inputs": [
							{
								"referenceName": "SourceTermType",
								"type": "DatasetReference",
								"parameters": {}
							}
						],
						"outputs": [
							{
								"referenceName": "DestinationTermTypeSOURCE",
								"type": "DatasetReference",
								"parameters": {}
							}
						]
					}
				],
				"folder": {
					"name": "PortThesaurus"
				},
				"annotations": []
			},
			"dependsOn": []
		}
	]
}